# VM Package Documentation

## Overview

The **VM (Virtual Machine)** package implements a **stack-based bytecode interpreter** for Bhasa. It executes compiled bytecode generated by the compiler, providing fast and efficient program execution.

## Table of Contents

- [What is a VM?](#what-is-a-vm)
- [Architecture](#architecture)
- [Stack-Based Execution](#stack-based-execution)
- [Call Frames](#call-frames)
- [Opcode Execution](#opcode-execution)
- [Type System](#type-system)
- [OOP Support](#oop-support)
- [Performance](#performance)

## What is a VM?

A **Virtual Machine** is a software-based execution environment that runs bytecode. Unlike interpretation (tree-walking), the VM:
- ✅ Pre-compiles to bytecode
- ✅ Executes faster
- ✅ Uses less memory
- ✅ Enables optimizations

### Compilation Pipeline

```
Source Code → Lexer → Parser → AST → Compiler → Bytecode → VM → Execution
                                                              ↑
                                                         VM Package
```

## Architecture

### VM Structure

```go
type VM struct {
    constants []object.Object     // Constant pool from compiler
    
    stack []object.Object         // Value stack
    sp    int                     // Stack pointer
    
    globals []object.Object       // Global variables
    
    frames      []*Frame          // Call frame stack
    framesIndex int               // Current frame index
    
    // OOP support
    pendingConstructor *object.Closure
    pendingMethods     map[string]*object.Closure
}
```

### Key Components

#### 1. Constants Pool
- Stores literals and compiled functions
- Indexed by bytecode instructions
- Shared across all frames

#### 2. Value Stack
- **Size**: 2048 elements
- **Purpose**: Store intermediate values
- **Stack Pointer (sp)**: Points to next free slot
- **Top of Stack**: `stack[sp-1]`

#### 3. Globals Array
- **Size**: 65,536 slots
- **Purpose**: Store global variables
- **Indexed**: By compiler-assigned indices

#### 4. Call Frames
- **Max Frames**: 1024
- **Purpose**: Track function calls
- **Contains**: Instruction pointer, base pointer, closure

### Frame Structure

```go
type Frame struct {
    cl          *object.Closure  // Function being executed
    ip          int              // Instruction pointer
    basePointer int              // Stack base for this frame
}
```

## Stack-Based Execution

### How Stack-Based VMs Work

**Example:** `1 + 2 * 3`

**Bytecode:**
```
OpConstant 0    // Push 1
OpConstant 1    // Push 2
OpConstant 2    // Push 3
OpMul           // Pop 3, 2; Push 6
OpAdd           // Pop 6, 1; Push 7
```

**Stack Trace:**
```
Step 1: OpConstant 0
  Stack: [1]
  sp: 1

Step 2: OpConstant 1
  Stack: [1, 2]
  sp: 2

Step 3: OpConstant 2
  Stack: [1, 2, 3]
  sp: 3

Step 4: OpMul
  Pop: 3, 2
  Push: 2 * 3 = 6
  Stack: [1, 6]
  sp: 2

Step 5: OpAdd
  Pop: 6, 1
  Push: 1 + 6 = 7
  Stack: [7]
  sp: 1

Result: 7
```

### Stack Operations

#### Push

```go
func (vm *VM) push(o object.Object) error {
    if vm.sp >= StackSize {
        return fmt.Errorf("stack overflow")
    }
    vm.stack[vm.sp] = o
    vm.sp++
    return nil
}
```

**Operation:**
```
Before: stack[sp] = _, sp = 5
Push(42):
After: stack[5] = 42, sp = 6
```

#### Pop

```go
func (vm *VM) pop() object.Object {
    o := vm.stack[vm.sp-1]
    vm.sp--
    return o
}
```

**Operation:**
```
Before: stack[5] = 42, sp = 6
Pop():
After: return 42, sp = 5
```

## Call Frames

### What is a Call Frame?

A **call frame** represents a function invocation:
- Tracks execution position (IP)
- Isolates local variables
- Maintains stack segment
- Enables recursion

### Frame Stack Example

```bengali
ধরি factorial = ফাংশন(n) {
    যদি (n <= ১) {
        ফেরত ১;
    }
    ফেরত n * factorial(n - ১);
};

factorial(৩);
```

**Frame Stack:**
```
Frame 3: factorial(1)  IP=15, BP=16
  ↑
Frame 2: factorial(2)  IP=10, BP=8
  ↑
Frame 1: factorial(3)  IP=5,  BP=0
  ↑
Frame 0: main()        IP=20, BP=0
```

### Frame Management

#### Push Frame

```go
func (vm *VM) pushFrame(f *Frame) {
    vm.frames[vm.framesIndex] = f
    vm.framesIndex++
}
```

#### Pop Frame

```go
func (vm *VM) popFrame() *Frame {
    vm.framesIndex--
    return vm.frames[vm.framesIndex]
}
```

#### Current Frame

```go
func (vm *VM) currentFrame() *Frame {
    return vm.frames[vm.framesIndex-1]
}
```

## Opcode Execution

### Main Execution Loop

```go
func (vm *VM) Run() error {
    for vm.currentFrame().ip < len(vm.currentFrame().Instructions())-1 {
        vm.currentFrame().ip++
        
        ip = vm.currentFrame().ip
        ins = vm.currentFrame().Instructions()
        op = code.Opcode(ins[ip])
        
        switch op {
        case code.OpConstant:
            // Load constant
        case code.OpAdd:
            // Addition
        case code.OpCall:
            // Function call
        // ... more opcodes
        }
    }
    return nil
}
```

### Opcode Categories

#### 1. Stack Operations
- `OpConstant` - Load constant onto stack
- `OpPop` - Remove top of stack
- `OpNull` - Push null
- `OpTrue` - Push true
- `OpFalse` - Push false

#### 2. Arithmetic Operations
- `OpAdd` - Addition
- `OpSub` - Subtraction
- `OpMul` - Multiplication
- `OpDiv` - Division
- `OpMod` - Modulo

#### 3. Comparison Operations
- `OpEqual` - Equality test
- `OpNotEqual` - Inequality test
- `OpGreaterThan` - Greater than
- `OpGreaterThanEqual` - Greater or equal

#### 4. Logical Operations
- `OpBang` - Logical NOT
- `OpAnd` - Logical AND
- `OpOr` - Logical OR

#### 5. Bitwise Operations
- `OpBitAnd` - Bitwise AND
- `OpBitOr` - Bitwise OR
- `OpBitXor` - Bitwise XOR
- `OpBitNot` - Bitwise NOT
- `OpLeftShift` - Left shift
- `OpRightShift` - Right shift

#### 6. Control Flow
- `OpJump` - Unconditional jump
- `OpJumpNotTruthy` - Conditional jump
- `OpCall` - Function call
- `OpReturn` - Return (null)
- `OpReturnValue` - Return with value

#### 7. Variable Operations
- `OpSetGlobal` - Set global variable
- `OpGetGlobal` - Get global variable
- `OpSetLocal` - Set local variable
- `OpGetLocal` - Get local variable

#### 8. Data Structures
- `OpArray` - Create array
- `OpHash` - Create hash
- `OpStruct` - Create struct
- `OpIndex` - Index access

#### 9. Functions and Closures
- `OpClosure` - Create closure
- `OpGetFree` - Get free variable
- `OpGetBuiltin` - Get builtin function
- `OpCurrentClosure` - Get current closure

#### 10. OOP Operations
- `OpClass` - Define class
- `OpNewInstance` - Create instance
- `OpCallMethod` - Call method
- `OpGetThis` - Get 'this'
- `OpGetSuper` - Get 'super'
- `OpGetInstanceField` - Get field
- `OpSetInstanceField` - Set field

## Type System

### Numeric Type Promotion

Bhasa supports automatic type promotion for numeric operations:

```
Byte (8-bit) → Short (16-bit) → Int (32-bit) → Long (64-bit)
                                              ↘
                             Float (32-bit) → Double (64-bit)
```

### Type Conversion Functions

#### toInt64

```go
func (vm *VM) toInt64(obj object.Object) int64
```

Converts any numeric type to int64:
- Byte → int64
- Short → int64
- Int → int64
- Long → int64
- Float → int64 (truncated)
- Double → int64 (truncated)
- Char → int64

#### toFloat64

```go
func (vm *VM) toFloat64(obj object.Object) float64
```

Converts any numeric type to float64:
- All integer types → float64
- Float → float64
- Double → float64

### Type-Aware Operations

#### Integer Operations

```bengali
ধরি a: পূর্ণসংখ্যা = ১০;
ধরি b: পূর্ণসংখ্যা = ২০;
ধরি c = a + b;  // Result: Int(30)
```

#### Float Operations

```bengali
ধরি x: দশমিক = ৩.১৪;
ধরি y: পূর্ণসংখ্যা = ২;
ধরি z = x * y;  // Result: Float(6.28)
```

#### Type Promotion Example

```bengali
ধরি a: ছোট_সংখ্যা = ১০০;     // Short
ধরি b: দীর্ঘ_সংখ্যা = ২০০০; // Long
ধরি c = a + b;               // Result: Long (promoted)
```

## OOP Support

### Class Instantiation

```bengali
শ্রেণী Person {
    সার্বজনীন নাম: পাঠ্য;
    
    নির্মাতা(নাম: পাঠ্য) {
        এই.নাম = নাম;
    }
}

ধরি p = নতুন Person("রহিম");
```

**VM Operations:**
1. `OpClass` - Load class definition
2. `OpNewInstance` - Create instance
   - Allocate instance
   - Initialize fields to null
   - Call constructor
3. Push instance on stack

### Method Calls

```bengali
p.greet();
```

**VM Operations:**
1. `OpGetInstanceField` - Get method (returns BoundMethod)
2. `OpCallMethod` - Call with automatic 'this' injection

### Bound Methods

A **BoundMethod** wraps:
- Receiver (instance)
- Method (closure)

When called, receiver is automatically passed as first argument (`this`).

### Field Access

```bengali
লেখ(p.নাম);      // Get field
p.নাম = "করিম";  // Set field
```

**Operations:**
- `OpGetInstanceField` - Read field value
- `OpSetInstanceField` - Write field value

## Execution Examples

### Example 1: Simple Arithmetic

**Bhasa Code:**
```bengali
ধরি result = ৫ + ৩ * ২;
```

**Bytecode:**
```
0000 OpConstant 0    // 5
0003 OpConstant 1    // 3
0006 OpConstant 2    // 2
0009 OpMul           // 3 * 2 = 6
0010 OpAdd           // 5 + 6 = 11
0011 OpSetGlobal 0   // result = 11
0014 OpPop
```

**Execution:**
```
IP=0: Push 5          → Stack: [5]
IP=3: Push 3          → Stack: [5, 3]
IP=6: Push 2          → Stack: [5, 3, 2]
IP=9: Mul             → Stack: [5, 6]
IP=10: Add            → Stack: [11]
IP=11: SetGlobal(0)   → globals[0] = 11
IP=14: Pop            → Stack: []
```

### Example 2: Function Call

**Bhasa Code:**
```bengali
ধরি add = ফাংশন(a, b) {
    ফেরত a + b;
};

ধরি result = add(৫, ৩);
```

**Execution:**
```
1. Load closure → Stack: [closure]
2. SetGlobal(add)
3. GetGlobal(add) → Stack: [closure]
4. Push 5 → Stack: [closure, 5]
5. Push 3 → Stack: [closure, 5, 3]
6. OpCall(2):
   - Create Frame(BP=1)
   - Push frame
   - Set IP to function start
7. In function:
   - GetLocal(0) → a=5
   - GetLocal(1) → b=3
   - OpAdd → 8
   - OpReturnValue
8. Pop frame
9. Stack: [8]
10. SetGlobal(result)
```

### Example 3: Conditional

**Bhasa Code:**
```bengali
ধরি x = ১০;
যদি (x > ৫) {
    লেখ("বড়");
}
```

**Bytecode:**
```
0000 OpConstant 0        // 10
0003 OpSetGlobal 0       // x = 10
0006 OpPop
0007 OpGetGlobal 0       // x
0010 OpConstant 1        // 5
0013 OpGreaterThan       // x > 5
0014 OpJumpNotTruthy 23  // if false, jump to 23
0017 OpGetBuiltin 0      // লেখ
0019 OpConstant 2        // "বড়"
0022 OpCall 1            // লেখ("বড়")
0023 ...
```

## Error Handling

### Stack Overflow

```go
if vm.sp >= StackSize {
    return fmt.Errorf("stack overflow")
}
```

**Causes:**
- Deep recursion
- Too many nested expressions

### Division by Zero

```go
if rightValue == 0 {
    return fmt.Errorf("division by zero")
}
```

### Type Errors

```go
if !vm.isNumericType(operand.Type()) {
    return fmt.Errorf("unsupported type: %s", operand.Type())
}
```

### Out of Bounds

```go
if constIndex >= uint16(len(vm.constants)) {
    return fmt.Errorf("constant index %d out of range", constIndex)
}
```

## Performance

### Why VM is Faster than Tree-Walking

**Tree-Walking Interpreter:**
- Traverses AST nodes
- Recursive function calls
- Repeated lookups
- No optimization

**VM:**
- Pre-compiled bytecode
- Direct dispatch
- Stack-based (cache-friendly)
- Optimization opportunities

### Benchmarks (Approximate)

```
Fibonacci(30):
- Tree-walking: ~2000ms
- VM: ~200ms
- 10x speedup!
```

### Optimization Techniques

1. **Singleton Objects**
   ```go
   var True = &object.Boolean{Value: true}
   var False = &object.Boolean{Value: false}
   var Null = &object.Null{}
   ```
   Reuse common values instead of allocating.

2. **Type-Specific Operations**
   Separate integer and float operations for efficiency.

3. **Inline Common Operations**
   Stack push/pop are simple and inline-friendly.

4. **Minimal Allocation**
   Pre-allocate stacks and frames.

## Constants

```go
const StackSize = 2048       // Maximum stack depth
const GlobalsSize = 65536    // Maximum global variables
const MaxFrames = 1024       // Maximum nested calls
```

### Configuration Limits

| Limit | Value | Purpose |
|-------|-------|---------|
| Stack Size | 2048 | Intermediate values |
| Globals | 65,536 | Global variables |
| Frames | 1024 | Recursion depth |

## Usage Examples

### Basic Usage

```go
import (
    "bhasa/compiler"
    "bhasa/vm"
)

// Compile source
bytecode := compiler.Compile(program)

// Create VM
machine := vm.New(bytecode)

// Execute
err := machine.Run()
if err != nil {
    log.Fatal(err)
}

// Get result
result := machine.LastPoppedStackElem()
```

### With Existing Globals

```go
// First execution
vm1 := vm.New(bytecode1)
vm1.Run()

// Second execution (share globals)
vm2 := vm.NewWithGlobalsStore(bytecode2, vm1.globals)
vm2.Run()
```

### REPL Usage

```go
globals := make([]object.Object, vm.GlobalsSize)

for {
    input := readInput()
    program := parse(input)
    bytecode := compile(program)
    
    machine := vm.NewWithGlobalsStore(bytecode, globals)
    err := machine.Run()
    
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        result := machine.LastPoppedStackElem()
        fmt.Println(result.Inspect())
    }
}
```

## Summary

The **VM** package provides:

✅ **Stack-Based Execution**: Fast bytecode interpretation  
✅ **Call Frames**: Proper function call management  
✅ **Type System**: Rich numeric type support with promotion  
✅ **OOP Support**: Classes, methods, inheritance  
✅ **Error Handling**: Comprehensive error checking  
✅ **Performance**: 10x faster than tree-walking  
✅ **Closures**: First-class functions with captured variables  
✅ **Built-ins**: Native function support  

For detailed implementation information, see:
- [vm-documentation.md](./vm-documentation.md) - Complete VM reference
- [frame-documentation.md](./frame-documentation.md) - Call frame system

---

The VM is the execution engine of Bhasa, transforming compiled bytecode into running programs with speed and efficiency.

